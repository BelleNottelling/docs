# Зачем фреймворк?

Некоторые программисты категорически против использования фреймворков. Они утверждают, что фреймворки надуты, медленны и сложны в обучении. Они говорят, что фреймворки не нужны, и что вы можете писать лучший код без них. Есть определенно некоторые обоснованные аргументы против использования фреймворков. Однако, есть также много преимуществ в использовании фреймворков.

## Причины использования фреймворка

Вот несколько причин, почему вам может захотеться рассмотреть использование фреймворка:

- **Быстрая разработка**: Фреймворки предоставляют много функциональности из коробки. Это означает, что вы можете быстрее создавать веб-приложения. Вам не нужно писать столько кода, потому что фреймворк предоставляет много функциональности, которая вам нужна.
- **Согласованность**: Фреймворки предоставляют последовательный способ делать вещи. Это позволяет вам лучше понимать, как работает код, и упрощает понимание вашего кода другим разработчикам. Если вы пишете по скрипту, вы можете потерять последовательность между скриптами, особенно если работаете с командой разработчиков.
- **Безопасность**: Фреймворки предоставляют функции безопасности, которые помогают защищать ваши веб-приложения от распространенных угроз безопасности. Это означает, что вам не нужно так сильно беспокоиться о безопасности, потому что фреймворк заботится об этом за вас.
- **Сообщество**: У фреймворков есть большие сообщества разработчиков, которые вносят свой вклад в фреймворк. Это означает, что вы можете получить помощь от других разработчиков, когда у вас возникают вопросы или проблемы. Это также означает, что доступно множество ресурсов для помощи в изучении использования фреймворка.
- **Лучшие практики**: Фреймворки созданы с использованием лучших практик. Это значит, что вы можете учиться на фреймворке и использовать те же лучшие практики в своем собственном коде. Это может помочь вам стать лучшим программистом. Иногда вы не знаете, чего не знаете, и это может вам навредить в конечном итоге.
- **Расширяемость**: Фреймворки разработаны для расширения. Это означает, что вы можете добавлять свою собственную функциональность во фреймворк. Это позволяет вам создавать веб-приложения, адаптированные под ваши конкретные потребности.

Flight - это микро-фреймворк. Это означает, что он маленький и легковесный. Он не предоставляет столько функциональности, сколько более крупные фреймворки, такие как Laravel или Symfony. Однако он предоставляет много функциональности, которая вам нужна для создания веб-приложений. Он также легко изучить и использовать. Это делает его хорошим выбором для того, чтобы быстро и легко создавать веб-приложения. Если вы новичок во фреймворках, Flight - отличный начальный фреймворк для начала. Это поможет вам узнать преимущества использования фреймворков, не перегружая вас слишком сложной структурой. После того как у вас появится опыт с Flight, будет легче перейти на более сложные фреймворки, такие как Laravel или Symfony, однако Flight все равно может создать успешное и надежное приложение.

## Что такое Маршрутизация?

Маршрутизация - ядро фреймворка Flight, но что это такое? Маршрутизация - это процесс взятия URL и сопоставления его с определенной функцией в вашем коде. Вот как можно сделать так, чтобы ваш веб-сайт делал разные вещи в зависимости от запрашиваемого URL. Например, вы можете хотеть показать профиль пользователя, когда они посещают `/user/1234`, но показать список всех пользователей, когда они посещают `/users`. Все это реализуется через маршрутизацию.

Это может работать примерно так:

- Пользователь заходит в ваш браузер и вводит `http://example.com/user/1234`.
- Сервер получает запрос, смотрит на URL и передает его в ваш код приложения Flight.
- Допустим, в вашем коде Flight у вас есть что-то вроде `Flight::route('/user/@id', [ 'UserController', 'viewUserProfile' ]);`. Ваш код Flight смотрит на URL и видит, что он совпадает с определенным маршрутом, который вы определили, и затем запускает код, который вы определили для этого маршрута.
- Затем маршрутизатор Flight запустит и вызовет метод `viewUserProfile($id)` в классе `UserController`, передавая `1234` как аргумент `$id` в метод.
- Код в вашем методе `viewUserProfile()` затем будет выполняться и делать то, что вы ему сказали делать. Возможно, вы выведете некоторый HTML для страницы профиля пользователя, или если это RESTful API, вы можете вывести JSON-ответ с информацией о пользователе.
- Flight красиво упаковывает это, генерирует заголовки ответа и отправляет обратно в браузер пользователя.
- Пользователь радуется и делает себе теплый объятий!

### А почему это важно?

Наличие правильного централизованного маршрутизатора на самом деле может значительно упростить вашу жизнь! Просто сначала это может быть сложно увидеть. Вот несколько причин:

- **Централизованная маршрутизация**: Вы можете хранить все свои маршруты в одном месте. Это упрощает видеть, какие у вас есть маршруты и что они делают. Это также упрощает их изменение, если это потребуется.
- **Параметры маршрута**: Вы можете использовать параметры маршрута для передачи данных в ваши методы маршрута. Это отличный способ держать свой код чистым и организованным.
- **Группировка маршрутов**: Вы можете группировать маршруты вместе. Это отлично для организации вашего кода и для применения [промежуточного ПО](middleware) к группе маршрутов.
- **Псевдонимы маршрутов**: Вы можете назначить псевдоним маршруту, чтобы URL мог динамически генерироваться позже в вашем коде (например, как шаблон). Например, вместо жесткой фиксации `/user/1234` в вашем коде, вы можете ссылаться на псевдоним `user_view` и передавать `id` в качестве параметра. Это очень удобно, если вы решите изменить его на `/admin/user/1234` позже. Вам не придется изменять все свои жестко закодированные URL, только URL, привязанные к маршруту.
- **Промежуточное ПО маршрута**: Вы можете добавлять промежуточное ПО к вашим маршрутам. Промежуточное ПО изумительно сильно в добавлении конкретных поведений к вашему приложению, таким как аутентификация того, что определенный пользователь может получить доступ к маршруту или группе маршрутов.

Уверен, что вы знакомы с пошаговым способом создания веб-сайта. У вас может быть файл с именем `index.php`, в котором есть куча `if` операторов для проверки URL и затем запуск конкретной функции на основе URL. Это форма маршрутизации, но не очень организованная, и может быстро выйти из-под контроля. Система маршрутизации Flight - это намного более организованный и мощный способ обработки маршрутов.

Это?

```php

// /user/view_profile.php?id=1234
if ($_GET['id']) {
	$id = $_GET['id'];
	viewUserProfile($id);
}

// /user/edit_profile.php?id=1234
if ($_GET['id']) {
	$id = $_GET['id'];
	editUserProfile($id);
}

// и так далее...
```

Или это?

```php

// index.php
Flight::route('/user/@id', [ 'UserController', 'viewUserProfile' ]);
Flight::route('/user/@id/edit', [ 'UserController', 'editUserProfile' ]);

// Возможно, в вашем app/controllers/UserController.php
class UserController {
	public function viewUserProfile($id) {
		// сделать что-то
	}

	public function editUserProfile($id) {
		// сделать что-то
	}
}
```

Надеюсь, вы начинаете видеть преимущества использования централизованной системы маршрутизации. В долгосрочной перспективе ее гораздо легче управлять и понимать! 

## Запросы и Ответы

Flight предоставляет простой и легкий способ обработки запросов и ответов. Это ядро того, что делает веб-фреймворк. Он получает запрос от браузера пользователя, обрабатывает его, а затем отправляет обратно ответ. Именно так вы можете создавать веб-приложения, которые делают вещи, такие как показ пользовательского профиля, вход пользователя или публикация нового блога пользователя.

### Запросы

Запрос - это то, что браузер пользователя отправляет на ваш сервер при посещении вашего веб-сайта. Этот запрос содержит информацию о том, что пользователь хочет сделать. Например, он может содержать информацию о том, какой URL пользователь хочет посетить, какие данные пользователь хочет отправить на ваш сервер или какие данные пользователь хочет получить от вашего сервера. Важно заметить, что запрос является только для чтения. Вы не можете изменить запрос, но можете прочитать из него.

Flight предоставляет простой способ доступа к информации о запросе. Вы можете получить доступ к информации о запросе, используя метод `Flight::request()`. Этот метод возвращает объект `Request`, который содержит информацию о запросе. Вы можете использовать этот объект для доступа к информации о запросе, такой как URL, метод или данные, которые пользователь отправил на ваш сервер.

### Ответы

Ответ - это то, что ваш сервер отправляет обратно на браузер пользователя при посещении вашего веб-сайта. Этот ответ содержит информацию о том, что ваш сервер хочет сделать. Например, он может содержать информацию о том, какие данные ваш сервер хочет отправить пользователю, какие данные ваш сервер хочет получить от пользователя или какие данные ваш сервер хочет сохранить на компьютере пользователя.

Flight предоставляет простой способ отправить ответ на браузер пользователя. Вы можете отправить ответ, используя метод `Flight::response()`. Этот метод принимает объект `Response` в качестве аргумента и отправляет ответ на браузер пользователя. Вы можете использовать этот объект для отправки ответа на браузер пользователя, такого как HTML, JSON или файл. Flight помогает автоматически генерировать некоторые части ответа, чтобы упростить вещи, но в конечном итоге у вас есть контроль над тем, что вы отправляете обратно пользователю.