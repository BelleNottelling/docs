# Почему Фреймворк?

Некоторые программисты категорически против использования фреймворков. Они утверждают, что фреймворки являются раздутыми, медленными и сложными в изучении. Они говорят, что фреймворки излишни и что можно писать лучший код без них. Существуют определенные обоснованные моменты, касающиеся недостатков использования фреймворков. Однако существует также множество преимуществ использования фреймворков.

## Причины использования Фреймворков

Вот несколько причин, почему вам может захотеться использовать фреймворк:

- **Быстрая разработка**: Фреймворки предоставляют множество функциональности из коробки. Это означает, что вы можете быстрее создавать веб-приложения. Вам не нужно писать так много кода, потому что фреймворк предоставляет множество функциональностей, которые вам необходимы.
- **Согласованность**: Фреймворки предоставляют последовательный способ совершения действий. Это упрощает вам понимание того, как работает код, и упрощает понимание вашего кода другим разработчикам. Если вы пишете скрипт за скриптом, вы можете потерять согласованность между скриптами, особенно если работаете с командой разработчиков.
- **Безопасность**: Фреймворки предоставляют функции безопасности, которые помогают защитить ваши веб-приложения от общих угроз безопасности. Это означает, что вам не нужно так сильно беспокоиться о безопасности, потому что фреймворк заботится об этом за вас.
- **Сообщество**: У фреймворков есть большие сообщества разработчиков, которые вносят свой вклад в фреймворк. Это означает, что вы можете получить помощь от других разработчиков, когда у вас возникают вопросы или проблемы. Это также означает, что доступно множество ресурсов, помогающих вам научиться использовать фреймворк.
- **Лучшие практики**: Фреймворки созданы с использованием лучших практик. Это означает, что вы можете учиться у фреймворка и использовать те же лучшие практики в своем собственном коде. Это может помочь вам стать лучшим программистом. Иногда вы не знаете, чего не знаете, и это может на вас накрыться в конце концов.
- **Расширяемость**: Фреймворки разработаны для расширения. Это означает, что вы можете добавлять свои собственные функциональности в фреймворк. Это позволяет вам создавать веб-приложения, адаптированные под ваши конкретные нужды.

Flight - это микро-фреймворк. Это означает, что он является маленьким и легковесным. Он не предоставляет так много функциональности, как более крупные фреймворки, такие как Laravel или Symfony. Однако он предоставляет множество функциональностей, необходимых для создания веб-приложений. Он также легок в изучении и использовании. Это делает его хорошим выбором для быстрого и простого создания веб-приложений. Если вы новичок в фреймворках, Flight - отличный начальный фреймворк для начала. Он поможет вам понять преимущества использования фреймворков, не препятствуя вам излишней сложностью. После того как вы приобретете некоторый опыт работы с Flight, будет проще перейти на более сложные фреймворки, такие как Laravel или Symfony, однако Flight все равно может помочь вам создать успешное и надежное приложение.

## Что такое Маршрутизация?

Маршрутизация является ядром фреймворка Flight, но что это такое? Маршрутизация - это процесс преобразования URL-адреса и его сопоставления с определенной функцией в вашем коде. Именно так вы можете сделать ваш веб-сайт делать разные вещи в зависимости от запрошенного URL-адреса. Например, вы могли бы хотеть показать профиль пользователя, когда они посещают `/user/1234`, а показать список всех пользователей, когда они посещают `/users`. Все это делается с помощью маршрутизации.

Это может выглядеть примерно так:

- Пользователь переходит в браузере на `http://example.com/user/1234`.
- Сервер получает запрос, смотрит на URL и передает его в ваш код приложения Flight.
- Допустим, в вашем коде Flight у вас есть что-то вроде `Flight::route('/user/@id', [ 'UserController', 'viewUserProfile' ]);`. Ваш код приложения Flight смотрит на URL и видит, что он совпадает с определенным маршрутом, который вы определили, а затем запускает код, который вы определили для этого маршрута.
- Маршрутизатор Flight затем запустится и вызовет метод `viewUserProfile($id)` в классе `UserController`, передавая `1234` в качестве аргумента `$id` в метод.
- Код в вашем методе `viewUserProfile()` затем выполнится и сделает все, что вы ему скажете. Вы можете, например, выводить HTML-код страницы профиля пользователя или, если это RESTful API, вы можете выводить JSON-ответ с информацией о пользователе.
- Flight завернет это в красивый бант, сгенерирует заголовки ответа и отправит обратно в браузер пользователя.
- Пользователь наполнен радостью и дает себе теплый объятий!

### И Зачем это Важно?

Иметь правильный централизованный маршрутизатор действительно может значительно упростить вашу жизнь! Просто сначала это может быть сложно увидеть. Вот несколько причин, почему:

- **Централизованная Маршрутизация**: Вы можете сохранить все ваши маршруты в одном месте. Это позволяет увидеть, какие маршруты у вас есть и что они делают. Это также упрощает их изменение, если нужно.
- **Параметры Маршрутов**: Вы можете использовать параметры маршрутов для передачи данных в ваши методы маршрутов. Это отличный способ держать свой код чистым и организованным.
- **Группировка Маршрутов**: Вы можете группировать маршруты вместе. Это отлично для организации вашего кода и для применения [промежуточного ПО](middleware) к группе маршрутов.
- **Псевдонимы Маршрутов**: Вы можете назначить псевдоним маршруту, чтобы URL-адрес можно было динамически генерировать позже в вашем коде (например, как шаблон). Например, вместо закодированного URL-адреса `/user/1234` в вашем коде вы можете ссылаться на псевдоним `user_view` и передавать `id` в качестве параметра. Это замечательно в случае, если вы решите впоследствии изменить его на `/admin/user/1234`. Вам не нужно будет менять все свои захардкоженные URL-адреса, только URL, связанные с маршрутом.
- **Промежуточное ПО Маршрутов**: Вы можете добавлять промежуточное ПО к вашим маршрутам. Промежуточное ПО невероятно мощно в добавлении конкретных поведений к вашему приложению, таких как аутентификация, что определенный пользователь может получить доступ к маршруту или группе маршрутов.

Я уверен, что вы знакомы со способом создания веб-сайта путем создания скрипт за скриптом. У вас может быть файл с именем `index.php`, который содержит массу инструкций `if` для проверки URL и выполнения определенной функции на основе URL. Это форма маршрутизации, но она не очень организованная и может быстро выйти из-под контроля. Система маршрутизации Flight - это гораздо более организованный и мощный способ управления маршрутизацией.

Вот так?

```php

// /user/view_profile.php?id=1234
if ($_GET['id']) {
	$id = $_GET['id'];
	viewUserProfile($id);
}

// /user/edit_profile.php?id=1234
if ($_GET['id']) {
	$id = $_GET['id'];
	editUserProfile($id);
}

// и так далее...
```

Или так?

```php

// index.php
Flight::route('/user/@id', [ 'UserController', 'viewUserProfile' ]);
Flight::route('/user/@id/edit', [ 'UserController', 'editUserProfile' ]);

// Возможно, в вашем app/controllers/UserController.php
class UserController {
	public function viewUserProfile($id) {
		// делать что-то
	}

	public function editUserProfile($id) {
		// делать что-то
	}
}
```

Надеюсь, вы начинаете видеть преимущества использования централизованной системы маршрутизации. Это намного удобнее управлять и понимать в долгосрочной перспективе!

## Запросы и Ответы

Flight предоставляет простой и удобный способ обработки запросов и ответов. Это ядро того, что делает веб-фреймворк. Он принимает запрос от браузера пользователя, обрабатывает его и затем отправляет ответ. Именно так вы можете создавать веб-приложения, показывать профиль пользователя, позволять пользователю войти в систему или публиковать новую статью в блоге.

### Запросы

Запрос - это то, что отправляет браузер пользователя на ваш сервер, когда они посещают ваш веб-сайт. Этот запрос содержит информацию о том, что пользователь хочет сделать. Например, он может содержать информацию о том, какой URL хочет посетить пользователь, какие данные он хочет отправить на ваш сервер или какие данные он хочет получить от вашего сервера. Важно знать, что запрос доступен только для чтения. Вы не можете изменить запрос, но можете читать его.

Flight предоставляет простой способ доступа к информации о запросе. Вы можете получить доступ к информации о запросе, используя метод `Flight::request()`. Этот метод возвращает объект `Request`, который содержит информацию о запросе. Вы можете использовать этот объект для доступа к информации о запросе, такой как URL, метод или данные, которые пользователь отправил на ваш сервер.

### Ответы

Ответ - это то, что ваш сервер отправляет обратно в браузер пользователя, когда они посещают ваш веб-сайт. Этот ответ содержит информацию о том, что ваш сервер хочет сделать. Например, он может содержать информацию о том, какие данные ваш сервер хочет отправить пользователю, какие данные ваш сервер хочет получить от пользователя или какие данные ваш сервер хочет хранить на компьютере пользователя.

Flight предоставляет простой способ отправки ответа в браузер пользователя. Вы можете отправить ответ, используя метод `Flight::response()`. Этот метод принимает объект `Response` в качестве аргумента и отправляет ответ в браузер пользователя. Вы можете использовать этот объект для отправки ответа в браузер пользователя, такого как HTML, JSON или файл. Flight помогает вам автоматически создавать некоторые части ответа, чтобы упростить вещи, но в конечном итоге у вас есть контроль над тем, что вы отправляете обратно пользователю.