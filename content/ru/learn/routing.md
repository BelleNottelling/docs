# Маршрутизация

> **Примечание:** Хотите узнать больше о маршрутизации? Посетите страницу ["почему фреймворк?"](/learn/why-frameworks) для более подробного объяснения.

Основная маршрутизация в Flight выполняется путем сопоставления шаблона URL с функцией обратного вызова или массивом класса и метода.

```php
Flight::route('/', function(){
    echo 'Привет, мир!';
});
```

Функция обратного вызова может быть любым объектом, который можно вызвать. Таким образом, вы можете использовать обычную функцию:

```php
function hello(){
    echo 'Привет, мир!';
}

Flight::route('/', 'hello');
```

Или метод класса:

```php
class Greeting {
    public static function hello() {
        echo 'Привет, мир!';
    }
}

Flight::route('/', array('Greeting','hello'));
```

Или метод объекта:

```php

// Greeting.php
class Greeting
{
    public function __construct() {
        $this->name = 'Иванов Иван';
    }

    public function hello() {
        echo "Привет, {$this->name}!";
    }
}

// index.php
$greeting = new Greeting();

Flight::route('/', array($greeting, 'hello'));
```

Маршруты сопоставляются в порядке их определения. Первый совпавший маршрут будет вызван.

## Маршрутизация метода

По умолчанию шаблоны маршрутов сопоставляются со всеми методами запроса. Вы можете реагировать
на конкретные методы, указав идентификатор перед URL.

```php
Flight::route('GET /', function () {
  echo 'Я получил GET-запрос.';
});

Flight::route('POST /', function () {
  echo 'Я получил POST-запрос.';
});
```

Вы также можете сопоставить несколько методов с одним обратным вызовом, используя разделитель `|`:

```php
Flight::route('GET|POST /', function () {
  echo 'Я получил GET- или POST-запрос.';
});
```

Кроме того, вы можете получить объект Router, который имеет некоторые вспомогательные методы для использования:

```php

$router = Flight::router();

// сопоставляет все методы
$router->map('/', function() {
	echo 'Привет, мир!';
});

// GET-запрос
$router->get('/пользователи', function() {
	echo 'пользователи';
});
// $router->post();
// $router->put();
// $router->delete();
// $router->patch();
```

## Регулярные выражения

Вы можете использовать регулярные выражения в ваших маршрутах:

```php
Flight::route('/пользователь/[0-9]+', function () {
  // Это совпадет с /пользователь/1234
});
```

Хотя этот метод доступен, рекомендуется использовать именованные параметры, или
именованные параметры с регулярными выражениями, так как они более читаемы и легче поддерживать.

## Именованные параметры

Вы можете указать именованные параметры в ваших маршрутах, которые будут переданы
вашей функции обратного вызова.

```php
Flight::route('/@name/@id', function (string $name, string $id) {
  echo "привет, $name ($id)!";
});
```

Вы также можете включать регулярные выражения с именованными параметрами, используя
разделитель `:`:

```php
Flight::route('/@name/@id:[0-9]{3}', function (string $name, string $id) {
  // Это совпадет с /боб/123
  // Но не совпадет с /боб/12345
});
```

> **Примечание:** Сопоставление групп регулярных выражений `()` с именованными параметрами не поддерживается. :'(

## Опциональные параметры

Вы можете указать именованные параметры, которые являются необязательными для сопоставления,
обернув сегменты в круглые скобки.

```php
Flight::route(
  '/блог(/@год(/@месяц(/@день)))',
  function(?string $год, ?string $месяц, ?string $день) {
    // Это совпадет со следующими URL-ами:
    // /блог/2012/12/10
    // /блог/2012/12
    // /блог/2012
    // /блог
  }
);
```

Любые несопоставленные необязательные параметры будут переданы как `NULL`.

## Маски

Сопоставление происходит только на отдельных сегментах URL. Если вы хотите сопоставить несколько
сегментов, вы можете использовать маску `*`.

```php
Flight::route('/блог/*', function () {
  // Это совпадет с /блог/2000/02/01
});
```

Для маршрутизации всех запросов к одному обратному вызову вы можете сделать следующее:

```php
Flight::route('*', function () {
  // Сделайте что-нибудь
});
```

## Передача

Вы можете передать выполнение на следующий сопоставленный маршрут, вернув `true` из
вашей функции обратного вызова.

```php
Flight::route('/пользователь/@name', function (string $name) {
  // Проверьте некоторое условие
  if ($name !== "Боб") {
    // Продолжить к следующему маршруту
    return true;
  }
});

Flight::route('/пользователь/*', function () {
  // Это будет вызвано
});
```

## Псевдоним маршрута

Вы можете назначить псевдоним маршруту, чтобы URL можно было динамически генерировать позже в вашем коде (например, как шаблон).

```php
Flight::route('/пользователи/@id', function($id) { echo 'пользователь:'.$id; }, false, 'просмотр_пользователя');

// позже где-то в коде
Flight::getUrl('просмотр_пользователя', [ 'id' => 5 ]); // вернет '/пользователи/5'
```

Это особенно полезно, если ваш URL случайно изменится. В приведенном примере допустим, что пользователи были перенесены в `/админ/пользователи/@id` вместо этого.
Благодаря использованию псевдонима, вам не нужно изменять везде, где вы ссылаетесь на псевдоним, потому что псевдоним теперь вернет `/админ/пользователи/5` как в приведенном выше примере.

Псевдоним маршрута по-прежнему работает в группах:

```php
Flight::group('/пользователи', function() {
    Flight::route('/@id', function($id) { echo 'пользователь:'.$id; }, false, 'просмотр_пользователя');
});


// позже где-то в коде
Flight::getUrl('просмотр_пользователя', [ 'id' => 5 ]); // вернет '/пользователи/5'
```

## Информация о маршруте

Если вы хотите изучить информацию о сопоставленном маршруте, вы можете запросить маршрутный
объект, чтобы передать его в вашу функцию обратного вызова, передав `true` в качестве третьего параметра в
метод маршрута. Объект маршрута всегда будет последним параметром, переданным в вашу
функцию обратного вызова.

```php
Flight::route('/', function(\flight\net\Route $route) {
  // Массив сопоставленных методов HTTP
  $route->methods;

  // Массив именованных параметров
  $route->params;

  // Сопоставленное регулярное выражение
  $route->regex;

  // Содержит содержимое любого '*' используемого в шаблоне URL
  $route->splat;

  // Показывает путь url... если вам действительно это нужно
  $route->pattern;

  // Показывает какой middleware назначен этому
  $route->middleware;

  // Показывает псевдоним назначенный этому маршруту
  $route->alias;
}, true);
```

## Группировка маршрутов

Могут возникнуть случаи, когда вы захотите группировать связанные маршруты вместе (например, `/api/v1`).
Вы можете сделать это, используя метод `group`:

```php
Flight::group('/api/v1', function () {
  Flight::route('/пользователи', function () {
	// Совпадает с /api/v1/пользователи
  });

  Flight::route('/посты', function () {
	// Совпадает с /api/v1/посты
  });
});
```

Вы даже можете вкладывать группы в группы:

```php
Flight::group('/api', function () {
  Flight::group('/v1', function () {
	// Flight::get() получает переменные, не устанавливает маршрут! См. объектный контекст ниже
	Flight::route('GET /пользователи', function () {
	  // Совпадает с GET /api/v1/пользователи
	});

	Flight::post('/посты', function () {
	  // Совпадает с POST /api/v1/посты
	});

	Flight::put('/посты/1', function () {
	  // Совпадает с PUT /api/v1/посты
	});
  });
  Flight::group('/v2', function () {

	// Flight::get() получает переменные, не устанавливает маршрут! См. объектный контекст ниже
	Flight::route('GET /пользователи', function () {
	  // Совпадает с GET /api/v2/пользователи
	});
  });
});
```

### Группировка с объектным контекстом

Вы все равно можете использовать группировку маршрутов с объектом `Engine` следующим образом:

```php
$app = new \flight\Engine();
$app->group('/api/v1', function (Router $router) {

  // используйте переменную $router
  $router->get('/пользователи', function () {
	// Совпадает с GET /api/v1/пользователи
  });

  $router->post('/посты', function () {
	// Совпадает с POST /api/v1/посты
  });
});
```

## Потоковая передача

Теперь вы можете передавать ответы клиенту, используя метод `streamWithHeaders()`.
Это полезно для отправки больших файлов, длительных процессов или создания крупных ответов.
Потоковая передача обработки маршрута осуществляется несколько иначе, чем обычный маршрут.

> **Примечание:** Передача ответов в поток доступна только если установлен параметр [`flight.v2.output_buffering`](/learn/migrating-to-v3#output_buffering) в значение false.

```php
Flight::route('/поток-пользователей', function() {

	// каким-либо образом получайте вашу информацию, просто в качестве примера...
	$users_stmt = Flight::db()->query("SELECT id, first_name, last_name FROM users");

	echo '{';
	$user_count = count($users);
	while($user = $users_stmt->fetch(PDO::FETCH_ASSOC)) {
		echo json_encode($user);
		if(--$user_count > 0) {
			echo ',';
		}

		// Это необходимо для отправки данных клиенту
		ob_flush();
	}
	echo '}';

// Вот как вы установите заголовки перед началом потоковой передачи.
})->streamWithHeaders([
	'Content-Type' => 'application/json',
	// необязательный код статуса, по умолчанию 200
	'status' => 200
]);
```