# Маршрутизация

Маршрутизация в Flight выполняется путем сопоставления шаблона URL с функцией обратного вызова.

```php
Flight::route('/', function(){
    echo 'Привет, мир!';
});
```

Обратный вызов может быть любым объектом, который можно вызвать. Итак, вы можете использовать обычную функцию:

```php
function hello(){
    echo 'Привет, мир!';
}

Flight::route('/', 'hello');
```

Или метод класса:

```php
class Greeting {
    public static function hello() {
        echo 'Привет, мир!';
    }
}

Flight::route('/', array('Greeting','hello'));
```

Или метод объекта:

```php
class Greeting
{
    public function __construct() {
        $this->name = 'Иванов Иван';
    }

    public function hello() {
        echo "Привет, {$this->name}!";
    }
}

$greeting = new Greeting();

Flight::route('/', array($greeting, 'hello'));
```

Маршруты сопоставляются в порядке их определения. Первый маршрут, который сопоставляется с запросом, будет вызван.

## Метод маршрутизации

По умолчанию шаблоны маршрутов сопоставляются со всеми методами запроса. Вы можете отвечать на конкретные методы, указав идентификатор перед URL.

```php
Flight::route('GET /', function () {
  echo 'Я получил запрос GET.';
});

Flight::route('POST /', function () {
  echo 'Я получил запрос POST.';
});
```

Вы также можете сопоставить несколько методов с одним обратным вызовом, используя разделитель `|`:

```php
Flight::route('GET|POST /', function () {
  echo 'Я получил запрос GET или POST.';
});
```

## Регулярные выражения

Вы можете использовать регулярные выражения в своих маршрутах:

```php
Flight::route('/пользователь/[0-9]+', function () {
  // Это будет соответствовать /пользователь/1234
});
```

## Именованные параметры

Вы можете указать именованные параметры в ваших маршрутах, которые будут переданы в вашу функцию обратного вызова.

```php
Flight::route('/@name/@id', function (string $name, string $id) {
  echo "Привет, $name ($id)!";
});
```

Вы также можете включать регулярные выражения с именованными параметрами, используя разделитель `:`:

```php
Flight::route('/@name/@id:[0-9]{3}', function (string $name, string $id) {
  // Это будет соответствовать /боб/123
  // Но не будет соответствовать /боб/12345
});
```

Сопоставление групп регулярных выражений `()` с именованными параметрами не поддерживается.

## Необязательные параметры

Вы можете указать именованные параметры, которые являются необязательными для сопоставления, обернув их в скобки.

```php
Flight::route(
  '/блог(/@год(/@месяц(/@день)))',
  function(?string $год, ?string $месяц, ?string $день) {
    // Это будет соответствовать следующим URL-адресам:
    // /блог/2012/12/10
    // /блог/2012/12
    // /блог/2012
    // /блог
  }
);
```

Любые несопоставленные необязательные параметры будут переданы как NULL.

## Подстановочные знаки

Сопоставление выполняется только для отдельных сегментов URL. Если вы хотите сопоставить несколько сегментов, вы можете использовать подстановочный знак `*`.

```php
Flight::route('/блог/*', function () {
  // Это будет соответствовать /блог/2000/02/01
});
```

Чтобы направить все запросы на один обратный вызов, вы можете сделать следующее:

```php
Flight::route('*', function () {
  // Сделать что-то
});
```

## Передача управления

Вы можете передать выполнение следующему подходящему маршруту, вернув `true` из вашей функции обратного вызова.

```php
Flight::route('/пользователь/@name', function (string $name) {
  // Проверьте некоторое условие
  if ($name !== "Иван") {
    // Продолжить к следующему маршруту
    return true;
  }
});

Flight::route('/пользователь/*', function () {
  // Это будет вызвано
});
```

## Информация о маршруте

Если вы хотите изучить информацию о соответствующем маршруте, вы можете запросить передачу объекта маршрута в ваш обратный вызов, передав `true` в качестве третьего параметра метода маршрута. Объект маршрута всегда будет передан последним параметром в вашу функцию обратного вызова.

```php
Flight::route('/', function(\flight\net\Route $route) {
  // Массив совпавших с HTTP-методами
  $route->methods;

  // Массив именованных параметров
  $route->params;

  // Совпавшее регулярное выражение
  $route->regex;

  // Содержит содержимое любого '*' в шаблоне URL
  $route->splat;
}, true);
```

## Группировка маршрутов

Могут возникнуть случаи, когда вам захочется группировать связанные маршруты вместе (например, `/api/v1`). Вы можете сделать это, используя метод `group`:

```php
Flight::group('/api/v1', function () {
  Flight::route('/пользователи', function () {
	// Соответствует /api/v1/пользователи
  });

  Flight::route('/посты', function () {
	// Соответствует /api/v1/посты
  });
});
```

Вы можете даже вкладывать группы групп:

```php
Flight::group('/api', function () {
  Flight::group('/v1', function () {
	// Flight::get() получает переменные, он не устанавливает маршрут! Смотрите контекст объекта ниже
	Flight::route('GET /пользователи', function () {
	  // Соответствует GET /api/v1/пользователи
	});

	Flight::post('/посты', function () {
	  // Соответствует POST /api/v1/посты
	});

	Flight::put('/посты/1', function () {
	  // Соответствует PUT /api/v1/посты
	});
  });
  Flight::group('/v2', function () {

	// Flight::get() получает переменные, он не устанавливает маршрут! Смотрите контекст объекта ниже
	Flight::route('GET /пользователи', function () {
	  // Соответствует GET /api/v2/пользователи
	});
  });
});
```

### Группировка с объектным контекстом

Вы все равно можете использовать группировку маршрутов с объектом `Engine` следующим образом:

```php
$app = new \flight\Engine();
$app->group('/api/v1', function (Router $router) {
  $router->get('/пользователи', function () {
	// Соответствует GET /api/v1/пользователи
  });

  $router->post('/посты', function () {
	// Соответствует POST /api/v1/посты
  });
});
```

## Псевдоним маршрута

Вы можете присвоить псевдоним маршруту, чтобы URL мог создаваться динамически позже в вашем коде (как, например, шаблон).

```php
Flight::route('/пользователи/@id', function($id) { echo 'пользователь:'.$id; }, false, 'view_user');

// позже в каком-то коде
Flight::getUrl('view_user', [ 'id' => 5 ]); // вернет '/пользователи/5'
```

Это особенно полезно, если ваш URL случайно изменится. В приведенном выше примере предположим, что пользователи перемещены в `/админ/пользователи/@id` вместо этого.
С присвоением псевдонима вам не нужно изменять везде, где вы упоминаете псевдоним, потому что псевдоним теперь вернет `/админ/пользователи/5` как в примере выше.

Псевдоним маршрута все еще работает в группах также:

```php
Flight::group('/пользователи', function() {
    Flight::route('/@id', function($id) { echo 'пользователь:'.$id; }, false, 'view_user');
});


// позже в каком-то коде
Flight::getUrl('view_user', [ 'id' => 5 ]); // вернет '/пользователи/5'
```

## Промежуточное программное обеспечение маршрута
Flight поддерживает промежуточное программное обеспечение маршрута и группы маршрутов. Промежуточное программное обеспечение - это функция, которая выполняется перед (или после) обратного вызова маршрута. Это отличный способ добавить проверку аутентификации API в вашем коде или проверить, есть ли у пользователя разрешение на доступ к маршруту.

Вот простой пример:

```php
// Если вы предоставляете только анонимную функцию, она будет выполнена перед обратным вызовом маршрута.
// нет "после" функций промежуточного программного обеспечения, за исключением классов (см. ниже)
Flight::route('/путь', function() { echo ' Вот я! '; })->addMiddleware(function() {
	echo 'Промежуточное первое!';
});

Flight::start();

// Это выведет "Промежуточное первое!  Вот я!"
```

Есть несколько очень важных замечаний о промежуточном программном обеспечении, о которых вы должны знать перед их использованием:
- Функции промежуточного программного обеспечения выполняются в порядке их добавления к маршруту. Выполнение аналогично тому, как это делает [Slim Framework](https://www.slimframework.com/docs/v4/concepts/middleware.html#how-does-middleware-work).
   - Передние выполняются в порядке добавления, а После выполнения в обратном порядке.
- Если ваша функция промежуточного программного обеспечения возвращает false, все выполнение прекращается, и генерируется ошибка 403 Forbidden. Вероятно, вам захочется обрабатывать это более грамотно с помощью `Flight::redirect()` или чего-то подобного.
- Если вам нужны параметры из вашего маршрута, они будут переданы в виде одного массива в вашу функцию промежуточного программного обеспечения (`function($params) { ... }` или `public function before($params) {}`). Причина в том, что вы можете структурировать свои параметры в группы, и в некоторых из этих групп ваши параметры могут фактически появиться в другом порядке, что сломает функцию промежуточного программного обеспечения, обращающуюся к неправильному параметру. Таким образом, вы можете получить к ним доступ по имени, а не по позиции.

### Классы промежуточного программного обеспечения

Промежуточное программное обеспечение также можно зарегистрировать как класс. Если вам нужна функциональность "после", вы должны использовать класс.

```php
class MyMiddleware {
	public function before($params) {
		echo 'Промежуточное первое!';
	}

	public function after($params) {
		echo 'Промежуточное последнее!';
	}
}

$MyMiddleware = new MyMiddleware();
Flight::route('/путь', function() { echo ' Вот я! '; })->addMiddleware($MyMiddleware); // также ->addMiddleware([ $MyMiddleware, $MyMiddleware2 ]);

Flight::start();

// Это отобразит "Промежуточное первое! Вот я! Промежуточное последнее!"
```

### Группы промежуточного программного обеспечения

Вы можете добавить группу маршрутов, и затем каждый маршрут в этой группе также будет иметь то же промежуточное программное обеспечение. Это полезно, если вам нужно сгруппировать несколько маршрутов по, скажем, аутентификации API для проверки ключа API в заголовке.

```php

// добавлено в конце метода группировки
Flight::group('/api', function() {
    Flight::route('/пользователи', function() { echo 'пользователи'; }, false, 'пользователи');
	Flight::route('/пользователи/@id', function($id) { echo 'пользователь:'.$id; }, false, 'view_user');
}, [ new ApiAuthMiddleware() ]);