## Маршрутизация

> **Примечание:** Хотите узнать больше о маршрутизации? Посмотрите страницу [почему фреймворки](/learn/why-frameworks) для более подробного объяснения.

Основная маршрутизация в Flight осуществляется путем сопоставления шаблона URL с функцией обратного вызова или массивом класса и метода.

```php
Flight::route('/', function(){
    echo 'привет, мир!';
});
```

Функцией обратного вызова может быть любой объект, который можно вызывать. Так что вы можете использовать обычную функцию:

```php
function hello(){
    echo 'привет, мир!';
}

Flight::route('/', 'hello');
```

Или метод класса:

```php
class Привет {
    public static function hello() {
        echo 'привет, мир!';
    }
}

Flight::route('/', array('Привет','hello'));
```

Или метод объекта:

```php

// Greeting.php
class Привет
{
    public function __construct() {
        $this->name = 'Иванов Иван';
    }

    public function hello() {
        echo "Привет, {$this->name}!";
    }
}

// index.php
$greeting = new Привет();

Flight::route('/', array($greeting, 'hello'));
```

Маршруты сопоставляются в том порядке, в котором они определены. Первый соответствующий запросу маршрут будет вызван.

## Маршрутизация метода

По умолчанию шаблоны маршрутов сопоставляются со всеми методами запроса. Вы можете отвечать
на конкретные методы, поместив идентификатор перед URL.

```php
Flight::route('GET /', function () {
  echo 'Я получил запрос GET.';
});

Flight::route('POST /', function () {
  echo 'Я получил запрос POST.';
});
```

Вы также можете сопоставить несколько методов одному обратному вызову, используя разделитель `|`:

```php
Flight::route('GET|POST /', function () {
  echo 'Я получил запрос GET или POST.';
});
```

Кроме того, вы можете получить объект маршрутизатора, в котором есть несколько вспомогательных методов для использования:

```php

$router = Flight::router();

// отображает все методы
$router->map('/', function() {
	echo 'привет, мир!';
});

// GET запрос
$router->get('/users', function() {
	echo 'пользователи';
});
// $router->post();
// $router->put();
// $router->delete();
// $router->patch();
```

## Регулярные выражения

Вы можете использовать регулярные выражения в ваших маршрутах:

```php
Flight::route('/пользователь/[0-9]+', function () {
  // Это совпадет с /пользователь/1234
});
```

Хотя этот метод доступен, рекомендуется использовать именованные параметры или
именованные параметры с регулярными выражениями, так как они более читаемы и легче обслуживать.

## Именованные параметры

Вы можете указать именованные параметры в ваших маршрутах, которые будут переданы
вашему функции обратного вызова.

```php
Flight::route('/@name/@id', function (string $name, string $id) {
  echo "привет, $name ($id)!";
});
```

Вы также можете включить регулярные выражения с вашими именованными параметрами, используя
разделитель `:`:

```php
Flight::route('/@name/@id:[0-9]{3}', function (string $name, string $id) {
  // Это совпадет с /bob/123
  // Но не совпадет с /bob/12345
});
```

> **Примечание:** Сопоставление групп регулярных выражений `()` с именованными параметрами не поддерживается. :'\(

## Опциональные параметры

Вы можете указать именованные параметры, которые являются необязательными для сопоставления, обернув
сегменты в скобки.

```php
Flight::route(
  '/блог(/@year(/@month(/@day)))',
  function(?string $year, ?string $month, ?string $day) {
    // Это совпадет с следующими URL-адресами:
    // /блог/2012/12/10
    // /блог/2012/12
    // /блог/2012
    // /блог
  }
);
```

Любые несовпавшие необязательные параметры будут переданы как `NULL`.

## Маскировки

Сопоставление происходит только на отдельных сегментах URL-адреса. Если вы хотите сопоставить несколько
сегментов, вы можете использовать маску `*`.

```php
Flight::route('/блог/*', function () {
  // Это совпадет с /блог/2000/02/01
});
```

Чтобы направить все запросы на один обратный вызов, вы можете сделать следующее:

```php
Flight::route('*', function () {
  // Сделай что-нибудь
});
```

## Передача

Вы можете передать выполнение на следующий совпадающий маршрут, вернув `true` из
вашей функции обратного вызова.

```php
Flight::route('/пользователь/@name', function (string $name) {
  // Проверьте некоторое условие
  if ($name !== "Иван") {
    // Продолжить к следующему маршруту
    return true;
  }
});

Flight::route('/пользователь/*', function () {
  // Здесь будет вызвана эта функция
});
```

## Псевдоним маршрута

Вы можете назначить псевдоним маршруту, чтобы URL можно было динамически генерировать позже в вашем коде (например, как шаблон, например).

```php
Flight::route('/пользователи/@id', function($id) { echo 'пользователь:'.$id; }, false, 'user_view');

// позже где-то в коде
Flight::getUrl('user_view', [ 'id' => 5 ]); // вернет '/пользователи/5'
```

Это особенно полезно, если ваш URL случайно поменяется. В приведенном выше примере допустим, что пользователи были перемещены в `/admin/users/@id`.
С использованием псевдонимов вам не нужно менять везде, где вы ссылаетесь на псевдоним, потому что псевдоним теперь вернет `/admin/users/5` как в
примере выше.

Псевдонимы маршрутов также работают в группах:

```php
Flight::group('/пользователи', function() {
    Flight::route('/@id', function($id) { echo 'пользователь:'.$id; }, false, 'user_view');
});


// позже где-то в коде
Flight::getUrl('user_view', [ 'id' => 5 ]); // вернет '/пользователи/5'
```

## Информация о маршруте

Если вы хотите изучить информацию о соответствующем маршруте, вы можете запросить маршрут
объект, чтобы передать его в ваш обратный вызов, передавая `true` как третий параметр в
метод маршрута. Объект маршрута всегда будет последним параметром, переданным в вашу
функцию обратного вызова.

```php
Flight::route('/', function(\flight\net\Route $route) {
  // Массив методов HTTP, сопоставленных
  $route->methods;

  // Массив именованных параметров
  $route->params;

  // Сопоставление регулярного выражения
  $route->regex;

  // Содержит содержимое любого '*' использованного в шаблоне URL
  $route->splat;

  // Показывает путь URL.... если это действительно нужно
  $route->pattern;

  // Показывает, какие middleware назначены этому
  $route->middleware;

  // Показывает назначенный этому маршруту псевдоним
  $route->alias;
}, true);
```

## Группировка маршрутов

Иногда вам может понадобиться группировать связанные маршруты вместе (например, `/api/v1`).
Вы можете сделать это, используя метод `group`:

```php
Flight::group('/api/v1', function () {
  Flight::route('/пользователи', function () {
	// Сопоставляется с /api/v1/users
  });

  Flight::route('/посты', function () {
	// Сопоставляется с /api/v1/posts
  });
});
```

Вы можете даже вкладывать группы групп:

```php
Flight::group('/api', function () {
  Flight::group('/v1', function () {
	// Flight::get() получает переменные, он не устанавливает маршрут! См. object context ниже
	Flight::route('GET /пользователи', function () {
	  // Сопоставляется с GET /api/v1/users
	});

	Flight::post('/посты', function () {
	  // Сопоставляется с POST /api/v1/posts
	});

	Flight::put('/посты/1', function () {
	  // Сопоставляется с PUT /api/v1/posts
	});
  });
  Flight::group('/v2', function () {

	// Flight::get() получает переменные, он не устанавливает маршрут! См. object context ниже
	Flight::route('GET /пользователи', function () {
	  // Сопоставляется с GET /api/v2/users
	});
  });
});
```

### Группировка с контекстом объекта

Вы все равно можете использовать группировку маршрутов с объектом `Engine` следующим образом:

```php
$app = new \flight\Engine();
$app->group('/api/v1', function (Router $router) {

  // используйте переменную `$router`
  $router->get('/пользователи', function () {
	// Сопоставляется с GET /api/v1/users
  });

  $router->post('/посты', function () {
	// Сопоставляется с POST /api/v1/posts
  });
});
```