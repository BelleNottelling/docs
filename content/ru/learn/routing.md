# Маршрутизация

> **Примечание:** Хотите узнать больше о маршрутизации? Посмотрите страницу ["почему фреймворк?"](/learn/why-frameworks) для более подробного объяснения.

Базовая маршрутизация в Flight выполняется путем сопоставления шаблона URL с функцией обратного вызова или массивом класса и метода.

```php
Flight::route('/', function(){
    echo 'привет, мир!';
});
```

Функция обратного вызова может быть любым объектом, который можно вызвать. Таким образом, вы можете использовать обычную функцию:

```php
function hello(){
    echo 'привет, мир!';
}

Flight::route('/', 'hello');
```

Или метод класса:

```php
class Greeting {
    public static function hello() {
        echo 'привет, мир!';
    }
}

Flight::route('/', array('Greeting','hello'));
```

Или метод объекта:

```php

// Greeting.php
class Greeting
{
    public function __construct() {
        $this->name = 'Джон Доу';
    }

    public function hello() {
        echo "Привет, {$this->name}!";
    }
}

// index.php
$greeting = new Greeting();

Flight::route('/', array($greeting, 'hello'));
```

Маршруты сопоставляются в порядке их определения. Первый маршрут для сопоставления запроса будет вызван.

## Маршрутизация методом

По умолчанию шаблоны маршрутов сопоставляются со всеми методами запроса. Вы можете ответить
на конкретные методы, разместив идентификатор перед URL.

```php
Flight::route('GET /', function () {
  echo 'Я получил запрос GET.';
});

Flight::route('POST /', function () {
  echo 'Я получил запрос POST.';
});
```

Также вы можете сопоставить несколько методов с единственным обратным вызовом, используя разделитель `|`:

```php
Flight::route('GET|POST /', function () {
  echo 'Я получил запрос GET или POST.';
});
```

Кроме того, вы можете получить объект Router, в котором есть несколько вспомогательных методов для использования:

```php

$router = Flight::router();

// отображает все методы
$router->map('/', function() {
	echo 'привет, мир!';
});

// запрос GET
$router->get('/users', function() {
	echo 'пользователи';
});
// $router->post();
// $router->put();
// $router->delete();
// $router->patch();
```

## Регулярные выражения

Вы можете использовать регулярные выражения в своих маршрутах:

```php
Flight::route('/user/[0-9]+', function () {
  // Это совпадет с /user/1234
});
```

Хотя этот метод доступен, рекомендуется использовать именованные параметры или
именованные параметры с регулярными выражениями, поскольку они более читаемы и легче поддерживать.

## Именованные параметры

Вы можете указать именованные параметры в своих маршрутах, которые будут переданы
вашей функции обратного вызова.

```php
Flight::route('/@name/@id', function (string $name, string $id) {
  echo "привет, $name ($id)!";
});
```

Вы также можете включить регулярные выражения с именованными параметрами, используя
разделитель `:`:

```php
Flight::route('/@name/@id:[0-9]{3}', function (string $name, string $id) {
  // Это совпадет с /bob/123
  // Но не совпадет с /bob/12345
});
```

> **Примечание:** Сопоставление групп регулярных выражений `()` с именованными параметрами не поддерживается. :'\(

## Дополнительные параметры

Вы можете указать именованные параметры, которые являются необязательными для сопоставления,
обернув сегменты в скобки.

```php
Flight::route(
  '/blog(/@year(/@month(/@day)))',
  function(?string $year, ?string $month, ?string $day) {
    // Это совпадет со следующими URL-адресами:
    // /blog/2012/12/10
    // /blog/2012/12
    // /blog/2012
    // /blog
  }
);
```

Любые несопоставленные параметры, которые являются необязательными, будут переданы как `NULL`.

## Маски

Сопоставление выполняется только для отдельных сегментов URL. Если вы хотите сопоставить несколько
сегментов, вы можете использовать подстановочный символ `*`.

```php
Flight::route('/blog/*', function () {
  // Это совпадет с /blog/2000/02/01
});
```

Чтобы направить все запросы на один обратный вызов, вы можете сделать следующее:

```php
Flight::route('*', function () {
  // Сделать что-то
});
```

## Передача

Вы можете передать выполнение на следующий совпадающий маршрут, вернув `true` из
вашей функции обратного вызова.

```php
Flight::route('/user/@name', function (string $name) {
  // Проверьте некоторое условие
  if ($name !== "Боб") {
    // Продолжить на следующий маршрут
    return true;
  }
});

Flight::route('/user/*', function () {
  // Здесь будет вызвано
});
```

## Присвоение маршрута

Вы можете назначить псевдоним маршруту, чтобы URL можно было динамически генерировать позже в вашем коде (например, как шаблон).

```php
Flight::route('/users/@id', function($id) { echo 'пользователь:'.$id; }, false, 'user_view');

// позже где-то в коде
Flight::getUrl('user_view', [ 'id' => 5 ]); // вернет '/users/5'
```

Это особенно полезно, если ваш URL случайно меняется. В приведенном выше примере, предположим, что пользователи были перемещены на `/admin/users/@id` вместо этого.
С использованием псевдонимов вам не нужно изменять место, где вы ссылаетесь на псевдоним, потому что псевдоним теперь вернет `/admin/users/5`, как в
приведенном выше примере.

Присвоение маршрута также работает в группах:

```php
Flight::group('/users', function() {
    Flight::route('/@id', function($id) { echo 'пользователь:'.$id; }, false, 'user_view');
});


// позже где-то в коде
Flight::getUrl('user_view', [ 'id' => 5 ]); // вернет '/users/5'
```

## Информация о маршрутах

Если вы хотите проверить информацию о совпадающем маршруте, вы можете запросить объект маршрута,
который передается в вашу функцию обратного вызова, передав `true` как третий параметр в
метод маршрута. Объект маршрута всегда будет последним переданным параметром в вашу
функцию обратного вызова.

```php
Flight::route('/', function(\flight\net\Route $route) {
  // Массив сопоставленных с HTTP-методами
  $route->methods;

  // Массив именованных параметров
  $route->params;

  // Сопоставленное регулярное выражение
  $route->regex;

  // Содержит содержимое любого '*' в используемом URL-шаблоне
  $route->splat;

  // Показывает путь URL ... если вам действительно это нужно
  $route->pattern;

  // Показывает, какое промежуточное ПО назначено этому
  $route->middleware;

  // Показывает псевдоним, присвоенный этому маршруту
  $route->alias;
}, true);
```

## Группирование маршрутов

Иногда вам может потребоваться группировать связанные маршруты вместе (например, `/api/v1`).
Это можно сделать с помощью метода `group`:

```php
Flight::group('/api/v1', function () {
  Flight::route('/users', function () {
	// Соответствует /api/v1/users
  });

  Flight::route('/posts', function () {
	// Соответствует /api/v1/posts
  });
});
```

Вы даже можете вкладывать группы в группы:

```php
Flight::group('/api', function () {
  Flight::group('/v1', function () {
	// Flight::get() получает переменные, он не назначает маршрут! См. объектный контекст ниже
	Flight::route('GET /users', function () {
	  // Соответствует GET /api/v1/users
	});

	Flight::post('/posts', function () {
	  // Соответствует POST /api/v1/posts
	});

	Flight::put('/posts/1', function () {
	  // Соответствует PUT /api/v1/posts
	});
  });
  Flight::group('/v2', function () {

	// Flight::get() получает переменные, он не назначает маршрут! См. объектный контекст ниже
	Flight::route('GET /users', function () {
	  // Соответствует GET /api/v2/users
	});
  });
});
```

### Группирование с объектным контекстом

Вы все равно можете использовать группирование маршрутов с объектом `Engine` следующим образом:

```php
$app = new \flight\Engine();
$app->group('/api/v1', function (Router $router) {

  // используйте переменную $router
  $router->get('/users', function () {
	// Соответствует GET /api/v1/users
  });

  $router->post('/posts', function () {
	// Соответствует POST /api/v1/posts
  });
});
```

## Потоковая передача

Теперь вы можете передавать ответы клиенту с использованием метода `streamWithHeaders()`.
Это полезно для отправки больших файлов, долго выполняемых процессов или создания больших ответов.
Потоковая маршутизация обрабатывается немного иначе, чем обычный маршрут.

> **Примечание:** Передача ответов по потоку доступна только при наличии установленного [`flight.v2.output_buffering`](/learn/migrating-to-v3#output_buffering) равного false.

```php
Flight::route('/stream-users', function() {

	// как бы вы там не извлекали ваши данные, просто в качестве примера...
	$users_stmt = Flight::db()->query("SELECT id, first_name, last_name FROM users");

	echo '{';
	$user_count = count($users);
	while($user = $users_stmt->fetch(PDO::FETCH_ASSOC)) {
		echo json_encode($user);
		if(--$user_count > 0) {
			echo ',';
		}

		// Это требуется для отправки данных клиенту
		ob_flush();
	}
	echo '}';

// Это то, как вы установите заголовки перед началом потоковой передачи.
})->streamWithHeaders([
	'Content-Type' => 'application/json',
	// необязательный код состояния, по умолчанию 200
	'status' => 200
]);
```