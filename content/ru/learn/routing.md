# Маршрутизация

> **Примечание:** Хотите узнать больше о маршрутизации? Посмотрите страницу [why frameworks](/learn/why-frameworks) для более подробного объяснения.

Основная маршрутизация в Flight осуществляется путем сопоставления шаблона URL с функцией обратного вызова или массивом класса и метода.

```php
Flight::route('/', function(){
    echo 'hello world!';
});
```

Обратный вызов может представлять собой любой объект, который можно вызвать. Так что вы можете использовать обычную функцию:

```php
function hello(){
    echo 'hello world!';
}

Flight::route('/', 'hello');
```

Либо метод класса:

```php
class Greeting {
    public static function hello() {
        echo 'hello world!';
    }
}

Flight::route('/', array('Greeting','hello'));
```

Либо метод объекта:

```php

// Greeting.php
class Greeting
{
    public function __construct() {
        $this->name = 'John Doe';
    }

    public function hello() {
        echo "Hello, {$this->name}!";
    }
}

// index.php
$greeting = new Greeting();

Flight::route('/', array($greeting, 'hello'));
```

Маршруты сопоставляются в порядке их определения. Первый подходящий маршрут для запроса будет вызван.

## Маршрутизация методом

По умолчанию шаблоны маршрутов сопоставляются со всеми методами запроса. Вы можете отвечать на конкретные методы, разместив идентификатор перед URL.

```php
Flight::route('GET /', function () {
  echo 'I received a GET request.';
});

Flight::route('POST /', function () {
  echo 'I received a POST request.';
});
```

Вы также можете сопоставить несколько методов с одним обратным вызовом, используя разделитель `|`:

```php
Flight::route('GET|POST /', function () {
  echo 'I received either a GET or a POST request.';
});
```

Кроме того, вы можете получить объект Router, который имеет некоторые вспомогательные методы для использования:

```php

$router = Flight::router();

// сопоставляются все методы
$router->map('/', function() {
	echo 'hello world!';
});

// Запрос GET
$router->get('/users', function() {
	echo 'users';
});
// $router->post();
// $router->put();
// $router->delete();
// $router->patch();
```

## Регулярные выражения

Вы можете использовать регулярные выражения в ваших маршрутах:

```php
Flight::route('/user/[0-9]+', function () {
  // Это совпадет с /user/1234
});
```

Хотя этот метод доступен, рекомендуется использовать именованные параметры или
именованные параметры с регулярными выражениями, поскольку они более читаемы и легче поддерживаются.

## Именованные параметры

Вы можете указать именованные параметры в ваших маршрутах, которые будут переданы
вашей функции обратного вызова.

```php
Flight::route('/@name/@id', function (string $name, string $id) {
  echo "hello, $name ($id)!";
});
```

Вы также можете включать регулярные выражения с именованными параметрами, используя
разделитель `:`:

```php
Flight::route('/@name/@id:[0-9]{3}', function (string $name, string $id) {
  // Это совпадет с /bob/123
  // Но не совпадет с /bob/12345
});
```

> **Примечание:** Сопоставление групп regex `()` с именованными параметрами не поддерживается. :'\(

## Опциональные параметры

Вы можете указать именованные параметры, которые являются необязательными для сопоставления, обернув
сегменты в круглые скобки.

```php
Flight::route(
  '/blog(/@year(/@month(/@day)))',
  function(?string $year, ?string $month, ?string $day) {
    // Это совпадет со следующими URL-адресами:
    // /blog/2012/12/10
    // /blog/2012/12
    // /blog/2012
    // /blog
  }
);
```

Любые несогласованные необязательные параметры будут переданы как `NULL`.

## Подстановочные знаки

Сопоставление выполняется только для отдельных сегментов URL. Если вам нужно сопоставлять несколько
сегментов, вы можете использовать подстановочный знак `*`.

```php
Flight::route('/blog/*', function () {
  // Это совпадет с /blog/2000/02/01
});
```

Чтобы направить все запросы на один обратный вызов, вы можете сделать следующее:

```php
Flight::route('*', function () {
  // Сделать что-то
});
```

## Переадресация

Вы можете передать выполнение следующему подходящему маршруту, вернув `true` из
вашей функции обратного вызова.

```php
Flight::route('/user/@name', function (string $name) {
  // Проверить некоторое условие
  if ($name !== "Bob") {
    // Продолжить к следующему маршруту
    return true;
  }
});

Flight::route('/user/*', function () {
  // Это будет вызвано
});
```

## Псевдоним маршрута

Вы можете присвоить псевдоним маршруту, чтобы URL можно было динамически генерировать позже в вашем коде (например, как шаблон).

```php
Flight::route('/users/@id', function($id) { echo 'user:'.$id; }, false, 'user_view');

// позже в коде где-то
Flight::getUrl('user_view', [ 'id' => 5 ]); // вернет '/users/5'
```

Это особенно полезно, если ваш URL случайно изменится. В приведенном выше примере предположим, что пользователи были перемещены на `/admin/users/@id` вместо этого.
Ima . С алиасом в действии вам не нужно будет менять места, где вы ссылаетесь на псевдоним, потому что псевдоним теперь будет возвращать `/admin/users/5` как в примере выше.

Псевдоним маршрута по-прежнему работает в группах:

```php
Flight::group('/users', function() {
    Flight::route('/@id', function($id) { echo 'пользователь:'.$id; }, false, 'user_view');
});


// позже в коде где-то
Flight::getUrl('user_view', [ 'id' => 5 ]); // вернет '/users/5'
```

## Информация о маршруте

Если вы хотите изучить информацию о сопоставленном маршруте, вы можете запросить объект маршрута
быть переданным в ваш обратный вызов, передав `true` в качестве третьего параметра в
метод маршрута. Объект маршрута всегда будет последним параметром, переданным вашей
функции обратного вызова.

```php
Flight::route('/', function(\flight\net\Route $route) {
  // Массив сопоставленных методов HTTP
  $route->methods;

  // Массив именованных параметров
  $route->params;

  // Сопоставленное регулярное выражение
  $route->regex;

  // Содержит содержимое любого использованного '*' в шаблоне URL
  $route->splat;

  // Показывает путь URL.... если вам действительно это нужно
  $route->шаблон;

  // Показывает какое промежуточное программное обеспечение назначено этому
  $route->middleware;

  // Показывает псевдоним, назначенный этому маршруту
  $route->alias;
}, true);
```

## Группировка маршрутов

Могут быть случаи, когда вы хотите группировать связанные маршруты вместе (например, `/api/v1`).
Вы можете сделать это, используя метод `group`:

```php
Flight::group('/api/v1', function () {
  Flight::route('/users', function () {
	// Совпадения /api/v1/users
  });

  Flight::route('/posts', function () {
	// Совпадения /api/v1/posts
  });
});
```

Вы даже можете вкладывать группы групп:

```php
Flight::group('/api', function () {
  Flight::group('/v1', function () {
	// Flight::get() получает переменные, это не устанавливает маршрут! См. объектный контекст ниже
	Flight::route('GET /users', function () {
	  // Cовпадения GET /api/v1/users
	});

	Flight::post('/posts', function () {
	  // Cовпадения POST /api/v1/posts
	});

	Flight::put('/posts/1', function () {
	  // Cовпадения PUT /api/v1/posts
	});
  });
  Flight::group('/v2', function () {

	// Flight::get() получает переменные, это не устанавливает маршрут! См. объектный контекст ниже
	Flight::route('GET /users', function () {
	  // Cовпадения GET /api/v2/users
	});
  });
});
```

### Группировка с контекстом объекта

Вы все равно можете использовать группировку маршрутов с объектом `Engine` следующим образом:

```php
$app = new \flight\Engine();
$app->group('/api/v1', function (Router $router) {

  // использовать переменную $router
  $router->get('/users', function () {
	// Cовпадения GET /api/v1/users
  });

  $router->post('/posts', function () {
	// Cовпадения POST /api/v1/posts
  });
});
```