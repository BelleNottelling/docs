# Безопасность

Безопасность играет большую роль, когда речь идет о веб-приложениях. Вы хотите убедиться, что ваше приложение защищено, и данные ваших пользователей в безопасности. Flight предоставляет ряд функций для помощи вам обеспечить безопасность ваших веб-приложений.

## CSRF-атаки

CSRF (межсайтовая подделка запросов) - это тип атаки, при котором злоумышленный сайт может заставить браузер пользователя отправить запрос на ваш сайт. Это может быть использовано для выполнения действий на вашем сайте без ведома пользователя. Flight не предоставляет встроенного механизма защиты от CSRF, но вы легко можете реализовать свой собственный, используя промежуточное программное обеспечение.

Сначала вам нужно сгенерировать токен CSRF и сохранить его в сессии пользователя. Затем вы можете использовать этот токен в ваших формах и проверять его при отправке формы.

```php
// Сгенерировать токен CSRF и сохранить его в сессии пользователя
// (предполагается, что вы создали объект сессии и присоединили его к Flight)
Flight::session()->set('csrf_token', bin2hex(random_bytes(32)) );
```

```html
<!-- Используйте токен CSRF в вашей форме -->
<form method="post">
	<input type="hidden" name="csrf_token" value="<?= Flight::session()->get('csrf_token') ?>">
	<!-- другие поля формы -->
</form>
```

И затем вы можете проверить токен CSRF, используя фильтры событий:

```php
// Это промежуточное программное обеспечение проверяет, является ли запрос POST-запросом, и если да, то проверяет, является ли токен CSRF действительным
Flight::before('start', function() {
	if(Flight::request()->method == 'POST') {

		// захватить токен csrf из значений формы
		$token = Flight::request()->data->csrf_token;
		if($token !== Flight::session()->get('csrf_token')) {
			Flight::halt(403, 'Недопустимый токен CSRF');
		}
	}
});
```

## XSS-атаки

XSS (межсайтовые скриптовые атаки) - это тип атаки, при котором злоумышленный сайт может внедрить код на вашем сайте. Большинство возможностей для этого появляются из значений форм, которые заполняют ваши конечные пользователи. **Никогда** не доверяйте выходным данным ваших пользователей! Всегда предполагайте, что все они - лучшие хакеры в мире. Они могут внедрить зловредный JavaScript или HTML на вашу страницу. Этот код может быть использован для кражи информации от ваших пользователей или выполнения действий на вашем сайте. Используя класс представления Flight, вы можете легко экранировать вывод, чтобы предотвратить атаки XSS.

```php

// Допустим, пользователь хитрый и пытается использовать это в качестве своего имени
$name = '<script>alert("XSS")</script>';

// Это экранирует вывод
Flight::view()->set('name', $name);
// Это приведет к выводу: &lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;

// Если вы используете что-то вроде Latte в качестве вашего класса представления, оно также автоматически экранирует это.
Flight::view()->render('шаблон', ['name' => $name]);
```

## SQL-инъекции

SQL-инъекция - это тип атаки, при которой злоумышленный пользователь может внедрить SQL-код в вашу базу данных. Это может быть использовано для кражи информации из вашей базы данных или выполнения действий в вашей базе данных. Опять же, **никогда** не доверяйте вводу ваших пользователей! Всегда предполагайте, что они готовы к бою. Вы можете использовать подготовленные выражения в ваших объектах `PDO`, чтобы предотвратить SQL-инъекции.

```php

// Предположим, что у вас зарегистрирован Flight::db() как ваш объект PDO
$statement = Flight::db()->prepare('SELECT * FROM users WHERE username = :username');
$statement->execute([':username' => $username]);
$users = $statement->fetchAll();

// Если вы используете класс PdoWrapper, это можно сделать легко в одну строку
$users = Flight::db()->fetchAll('SELECT * FROM users WHERE username = :username', [ 'username' => $username ]);

// Вы можете сделать то же самое с объектом PDO с использованием заполнителей ?
$statement = Flight::db()->fetchAll('SELECT * FROM users WHERE username = ?', [ $username ]);

// Просто обещайте, что никогда, НИКОГДА не сделаете что-то подобное...
$users = Flight::db()->fetchAll("SELECT * FROM users WHERE username = '{$username}' LIMIT 5");
// потому что что, если $username = "' OR 1=1; -- "; После построения запроса он выглядит
// так
// SELECT * FROM users WHERE username = '' OR 1=1; -- LIMIT 5
// Выглядит странно, но это допустимый запрос, который будет работать. Фактически,
// это очень распространенная атака SQL-инъекции, которая вернет всех пользователей.
```

## CORS

Обмен ресурсами между разными источниками (CORS) - это механизм, позволяющий запрашивать множество ресурсов (например, шрифты, JavaScript и т. д.) на веб-странице с другого домена, отличного от домена, из которого ресурс происходит. Flight не имеет встроенной функциональности, но это легко можно управлять с помощью промежуточного программного обеспечения или фильтров событий, аналогично CSRF.

```php

// app/middleware/CorsMiddleware.php

namespace app\middleware;

class CorsMiddleware
{
	public function before(array $params): void
	{
		$response = Flight::response();
		if (isset($_SERVER['HTTP_ORIGIN'])) {
			$this->allowOrigins();
			$response->header('Access-Control-Allow-Credentials: true');
			$response->header('Access-Control-Max-Age: 86400');
		}

		if ($_SERVER['REQUEST_METHOD'] == 'OPTIONS') {
			if (isset($_SERVER['HTTP_ACCESS_CONTROL_REQUEST_METHOD'])) {
				$response->header(
					'Access-Control-Allow-Methods: GET, POST, PUT, DELETE, PATCH, OPTIONS'
				);
			}
			if (isset($_SERVER['HTTP_ACCESS_CONTROL_REQUEST_HEADERS'])) {
				$response->header(
					"Access-Control-Allow-Headers: {$_SERVER['HTTP_ACCESS_CONTROL_REQUEST_HEADERS']}"
				);
			}
			$response->send();
			exit(0);
		}
	}

	private function allowOrigins(): void
	{
		$allowed = [
			'capacitor://localhost',
			'ionic://localhost',
			'http://localhost',
			'http://localhost:4200',
			'http://localhost:8080',
			'http://localhost:8100',
		];

		if (in_array($_SERVER['HTTP_ORIGIN'], $allowed)) {
			$response = Flight::response();
			$response->header("Access-Control-Allow-Origin: {$_SERVER['HTTP_ORIGIN']}");
		}
	}
}

// index.php или где у вас ваши маршруты
Flight::route('/users', function() {
	$users = Flight::db()->fetchAll('SELECT * FROM users');
	Flight::json($users);
})->addMiddleware(new CorsMiddleware());
```

## Заключение

Безопасность играет важную роль, и важно убедиться, что ваши веб-приложения защищены. Flight предоставляет ряд функций для помощи вам обеспечить безопасность ваших веб-приложений, но важно всегда быть бдительным и делать все возможное, чтобы сохранить данные ваших пользователей в безопасности. Всегда предполагайте худшее и никогда не доверяйте вводу от ваших пользователей. Всегда экранируйте вывод и используйте подготовленные выражения, чтобы предотвратить SQL-инъекции. Всегда используйте промежуточное программное обеспечение для защиты ваших маршрутов от атак CSRF и CORS. Если вы сделаете все это, то вы будете на верном пути к созданию безопасных веб-приложений.