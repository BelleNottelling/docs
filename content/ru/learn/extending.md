# Расширение

Flight разработан для того, чтобы быть расширяемым фреймворком. Фреймворк поставляется с набором 
стандартных методов и компонентов, но он позволяет вам отображать собственные методы, регистрировать 
собственные классы или даже переопределять существующие классы и методы.

Если вам нужен DIC (Dependency Injection Container), перейдите на 
страницу [Dependency Injection Container](dependency-injection-container).

## Отображение Методов

Для отображения вашего собственного простого пользовательского метода используйте функцию `map`:

```php
// Отобразите ваш метод
Flight::map('hello', function (string $name) {
  echo "привет $name!";
});

// Вызовите ваш пользовательский метод
Flight::hello('Боб');
```

Это используется больше, когда вам нужно передавать переменные в ваш метод, чтобы получить ожидаемое 
значение. Использование метода `register()` как показано ниже больше для передачи конфигурации и 
затем вызова вашего предварительно настроенного класса.

## Регистрация Классов

Для регистрации собственного класса и его настройки используйте функцию `register`:

```php
// Зарегистрируйте свой класс
Flight::register('user', User::class);

// Получите экземпляр вашего класса
$user = Flight::user();
```

Метод регистрации также позволяет передавать параметры конструктору вашего класса. Поэтому, когда 
вы загружаете ваш пользовательский класс, он будет предварительно инициализирован. Вы можете 
определить параметры конструктора, передавая дополнительный массив. Вот пример загрузки 
подключения к базе данных:

```php
// Зарегистрируйте класс с параметрами конструктора
Flight::register('db', PDO::class, ['mysql:host=localhost;dbname=test', 'user', 'pass']);

// Получите экземпляр вашего класса
// Это создаст объект с определенными параметрами
//
// new PDO('mysql:host=localhost;dbname=test','user','pass');
//
$db = Flight::db();

// и если вам он понадобится позднее в вашем коде, просто вызовите тот же метод снова
class SomeController {
  public function __construct() {
	$this->db = Flight::db();
  }
}
```

Если вы передаете дополнительный параметр обратного вызова, он будет выполнен немедленно 
после создания класса. Это позволяет вам выполнить любые процедуры настройки для вашего 
нового объекта. Функция обратного вызова принимает один параметр - экземпляр нового объекта.

```php
// Объект, который был создан, будет передан в обратный вызов
Flight::register(
  'db',
  PDO::class,
  ['mysql:host=localhost;dbname=test', 'user', 'pass'],
  function (PDO $db) {
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
  }
);
```

По умолчанию, каждый раз при загрузке вашего класса вы получите общий экземпляр.
Чтобы получить новый экземпляр класса, просто передайте `false` в качестве параметра:

```php
// Общий экземпляр класса
$shared = Flight::db();

// Новый экземпляр класса
$new = Flight::db(false);
```

Имейте в виду, что отображенные методы имеют приоритет над зарегистрированными классами. 
Если вы объявляете оба с одним и тем же именем, будет вызван только отображенный метод.

## Переопределение Методов Фреймворка

Flight позволяет вам переопределять его функциональность по умолчанию, чтобы адаптировать 
её под свои нужды, не изменяя никакой код.

К примеру, когда Flight не может соотнести URL с маршрутом, он вызывает метод `notFound`, 
который отправляет общий ответ с `HTTP 404`. Вы можете переопределить это поведение, 
используя метод `map`:

```php
Flight::map('notFound', function() {
  // Показать пользовательскую страницу 404
  include 'errors/404.html';
});
```

Кроме того, Flight позволяет вам заменить основные компоненты фреймворка.
Например, вы можете заменить стандартный класс маршрутизатора своим собственным классом:

```php
// Зарегистрируйте ваш пользовательский класс
Flight::register('router', MyRouter::class);

// Когда Flight загружает экземпляр маршрутизатора, он загрузит ваш класс
$myrouter = Flight::router();
```

Методы фреймворка, такие как `map` и `register`, однако не могут быть переопределены. 
Вы получите ошибку, если попытаетесь это сделать.