# Расширение / Контейнеры

Flight разработан для того, чтобы быть расширяемым фреймворком. Фреймворк поставляется с набором
стандартных методов и компонентов, но позволяет вам маппить собственные методы,
регистрировать собственные классы или даже переопределять существующие классы и методы.

## Маппинг методов

Чтобы замаппить собственный простой метод, используйте функцию `map`:

```php
// Замаппить свой метод
Flight::map('hello', function (string $name) {
  echo "привет $name!";
});

// Вызовите ваш собственный метод
Flight::hello('Боб');
```

Это используется в основном, когда вам нужно передать переменные в ваш метод для получения ожидаемого
результата. Использование метода `register()` вроде приведенного ниже больше для передачи
конфигурации, а затем вызова вашего предварительно сконфигурированного класса.

## Регистрация Классов / Контейнеризация

Чтобы зарегистрировать собственный класс и настроить его, используйте функцию `register`:

```php
// Зарегистрировать свой класс
Flight::register('user', User::class);

// Получить экземпляр вашего класса
$user = Flight::user();
```

Метод регистрации также позволяет передать параметры в конструктор вашего класса
Таким образом, когда вы загружаете ваш собственный класс, он будет предварительно инициализирован.
Можно определить параметры конструктора, передав дополнительный массив.
Вот пример загрузки соединения с базой данных:

```php
// Зарегистрировать класс с параметрами конструктора
Flight::register('db', PDO::class, ['mysql:host=localhost;dbname=test', 'user', 'pass']);

// Получить экземпляр вашего класса
// Это создаст объект с определенными параметрами
//
// new PDO('mysql:host=localhost;dbname=test','user','pass');
//
$db = Flight::db();

// и если вам понадобится позже в вашем коде, просто вызовите тот же метод снова
class SomeController {
  public function __construct() {
	$this->db = Flight::db();
  }
}
```

Если добавить дополнительный параметр обратного вызова, он будет выполнен немедленно
после создания класса. Это позволяет выполнить любые процедуры настройки для вашего
нового объекта. Функция обратного вызова принимает один параметр - экземпляр нового объекта.

```php
// Обратный вызов будет передан объект, который был создан
Flight::register(
  'db',
  PDO::class,
  ['mysql:host=localhost;dbname=test', 'user', 'pass'],
  function (PDO $db) {
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
  }
);
```

По умолчанию, каждый раз, когда вы загружаете ваш класс, вы получите общий экземпляр.
Чтобы получить новый экземпляр класса, просто передайте `false` в качестве параметра:

```php
// Общий экземпляр класса
$shared = Flight::db();

// Новый экземпляр класса
$new = Flight::db(false);
```

Имейте в виду, что замаппированные методы имеют приоритет перед зарегистрированными классами. Если вы
объявите оба используя одно и то же имя, будет вызван только замаппированный метод.

## Переопределение

Flight позволяет вам переопределить свою стандартную функциональность под свои нужды,
не изменяя при этом код.

Например, когда Flight не может сопоставить URL с маршрутом, он вызывает метод `notFound`,
который отправляет общий ответ `HTTP 404`. Вы можете переопределить это поведение
используя метод `map`:

```php
Flight::map('notFound', function() {
  // Показать пользовательскую страницу 404
  include 'errors/404.html';
});
```

Flight также позволяет вам заменить основные компоненты фреймворка.
Например, вы можете заменить стандартный класс Router собственным пользовательским классом:

```php
// Зарегистрировать ваш пользовательский класс
Flight::register('router', MyRouter::class);

// Когда Flight загрузит экземпляр Router, он загрузит ваш класс
$myrouter = Flight::router();
```

Однако методы фреймворка, такие как `map` и `register`, не могут быть переопределены. Вы получите
ошибку, если попытаетесь это сделать.